var sys = require('sys');
var tcp = require('net');
var tls = require('tls');
var irc = exports;

function bind(fn, scope) {
	var bindArgs = Array.prototype.slice.call(arguments);
	bindArgs.shift();
	bindArgs.shift();

	return function() {
		var args = Array.prototype.slice.call(arguments);
		fn.apply(scope, bindArgs.concat(args));
	};
}

function each(set, iterator) {
	for (var i = 0; i < set.length; i++) {
		var r = iterator(set[i], i);
		if (r === false) {
			return;
		}
	}
}

var Client = irc.Client = function(host, port, secure, iicert, debug) {
	this.host = host || 'localhost';
	this.port = port || 6667;
	this.debug = debug || false;
	this.secure = secure || false;
	this.iicert = iicert || false;
	
	this.connection = null;
	this.buffer = '';
	this.encoding = 'utf8';
	this.timeout = 300000;

	this.nick = null;
	this.user = null;
	this.real = null;
};
sys.inherits(Client, process.EventEmitter);

Client.prototype.connect = function(nick, user, real) {
	var connection;

	if (this.secure) {
		connection = tls.connect(this.port, this.host, {rejectUnauthorized: !this.iicert});
		connection.addListener('secureConnect', bind(this.onConnect, this));
	}
	else {
		connection = tcp.createConnection(this.port, this.host);
		connection.addListener('connect', bind(this.onConnect, this));
	}
	
	connection.setEncoding(this.encoding);
	connection.setTimeout(this.timeout);
	connection.addListener('data', bind(this.onReceive, this));
	connection.addListener('end', bind(this.onEof, this));
	connection.addListener('timeout', bind(this.onTimeout, this));
	connection.addListener('drain', bind(this.onDrain, this));
	connection.addListener('error', bind(this.onError, this));
	connection.addListener('close', bind(this.onClose, this));

	this.nick = nick;
	this.user = user || 'guest';
	this.real = real || 'Guest';

	this.connection = connection;
};

Client.prototype.destroyConnection = function(why) {
	this.connection.destroy();
	if (this.debug) sys.puts('connection destroyed (reason: '+why+')');
};

Client.prototype.disconnect = function(why) {
	this.destroyConnection(why);
	this.emit('DISCONNECT', why);
};

Client.prototype.disconnect = function(why) {
	this.connection.destroy();
	if (this.debug) sys.puts('disconnected (reason: '+why+')');
	this.emit('DISCONNECT', why);
};

Client.prototype.send = function(arg1) {
	if (this.connection.readyState !== 'open') {
		return this.disconnect('cannot send with readyState: '+this.connection.readyState);
	}

	var message = [];
	for (var i = 0; i< arguments.length; i++) {
		if (arguments[i]) {
			message.push(arguments[i]);
		}
	}
	message = message.join(' ');

	if (this.debug) sys.puts('> '+message);
	message = message + "\r\n";
	this.connection.write(message, this.encoding);
};

Client.prototype.parse = function(message) {
	var match = message.match(/(?:(:[^\s]+) )?([^\s]+) (.+)/);
	var parsed = {
		prefix: match[1],
		command: match[2]
	};

	var params = match[3].match(/(.*?) ?:(.*)/);
	if (params) {
		// Params before :
		params[1] = (params[1])
		? params[1].split(' ')
		: [];
		// Rest after :
		params[2] = params[2]
		? [params[2]]
		: [];

		params = params[1].concat(params[2]);
	} else {
		params = match[3].split(' ');
	}

	parsed.params = params;
	return parsed;
};

Client.prototype.onConnect = function() {
	this.send('NICK', this.nick);
	this.send('USER', this.user, '0', '*', ':'+this.real);
};

Client.prototype.onReceive = function(chunk) {
	this.buffer = this.buffer + chunk;
  
	while (this.buffer) {
		var offset = this.buffer.indexOf("\r\n");
		if (offset < 0) {
			return;
		}
  
		var message = this.buffer.substr(0, offset);
		this.buffer = this.buffer.substr(offset + 2);
		if (this.debug) sys.puts('< '+message);

		message = this.parse(message);

		if (message !== false) {
			this.emit.apply(this, [message.command, message.prefix].concat(message.params));
		}
	}
}; 

Client.prototype.onEof = function() {
	this.disconnect('eof');
};

Client.prototype.onTimeout = function() {
	this.disconnect('timeout');
};

Client.prototype.onDrain = function() {
	// Nothing here yet
};

Client.prototype.onError = function() {
	this.disconnect('socket error');
};

Client.prototype.onClose = function() {
	this.destroyConnection('close');
};
